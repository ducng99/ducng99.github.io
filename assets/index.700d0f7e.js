var xt=Object.defineProperty;var _t=(o,t,e)=>t in o?xt(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var s=(o,t,e)=>(_t(o,typeof t!="symbol"?t+"":t,e),e);import{R as P,L as Ct,S as G,P as x,a as O,M as kt,C as L,T as B,A as Lt,j as ot,r as z,b as bt,c as Pt}from"./vendor.a92123a6.js";const Bt=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const h of a.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&i(h)}).observe(document,{childList:!0,subtree:!0});function e(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerpolicy&&(a.referrerPolicy=n.referrerpolicy),n.crossorigin==="use-credentials"?a.credentials="include":n.crossorigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(n){if(n.ep)return;n.ep=!0;const a=e(n);fetch(n.href,a)}};Bt();const q=class{constructor(){s(this,"KeysDown",[])}static get Instance(){return this._instance||(this._instance=new q),this._instance}OnKeyDown(t){this.KeysDown.includes(t)||this.KeysDown.push(t)}OnKeyUp(t){this.KeysDown.remove(t)}Handle(){let t=!1,e=!1;const i=S.Instance.Player.MoveController;for(let n=0;n<this.KeysDown.length;n++)switch(this.KeysDown[n]){case"ArrowLeft":i.MoveLeft(),t=!0;break;case"ArrowRight":i.MoveRight(),t=!0;break;case"Space":case" ":e=i.Jump();break}t||i.StopHorizontal(),e||i.StopVertical()}};let v=q;s(v,"_instance");var C;(function(o){o.BottomBlocked="bottom_blocked",o.IsPie="is_pie",o.LeftBlocked="left_blocked",o.RightBlocked="right_blocked",o.TopBlocked="top_blocked"})(C||(C={}));var rt;(function(o){o.Bool="bool"})(rt||(rt={}));Array.prototype.remove=function(o){const t=this.indexOf(o);t>-1&&this.splice(t,1)};P.prototype.intersects=function(o){const t=this.x<o.x?o.x:this.x;if((this.right>o.right?o.right:this.right)<t)return!1;const i=this.y<o.y?o.y:this.y;return(this.bottom>o.bottom?o.bottom:this.bottom)>=i};function Tt(o){return new Promise(t=>{setTimeout(()=>t(),o)})}const Q=class{constructor(){s(this,"Loader",new Ct);s(this,"LoadedSpriteSheets",{})}static get Instance(){return this._instance||(this._instance=new Q),this._instance}async Load(t){for(;this.Loader.loading;)await Tt(10);if(this.LoadedSpriteSheets[t])return this.LoadedSpriteSheets[t];const e=await new Promise(i=>{this.Loader.add(t).load((n,a)=>{i(a[t])})});return this.LoadedSpriteSheets[t]=e,e}};let U=Q;s(U,"_instance");const Z=class{constructor(){s(this,"Textures",[])}static get Instance(){return this._instance||(this._instance=new Z),this._instance}async Load(t){try{const i=(await U.Instance.Load(t)).textures;i&&Object.values(i).forEach(n=>{n.baseTexture.scaleMode=G.NEAREST,this.Textures.push(n)})}catch(e){throw console.error(`Failed when loading texture from ${t}`),e}}};let T=Z;s(T,"_instance");const At={None:0,TopBlocked:0,BottomBlocked:0,LeftBlocked:0,RightBlocked:0,Interactable:0},F=Object.entries(At);for(let o=1;o<F.length;o++)F[o][1]=1<<o-1;const M=Object.fromEntries(F);class E{constructor(t,e){s(this,"Point1");s(this,"Point2");this.Point1=t,this.Point2=e}intersects(t){const e=this.Point1.x,i=this.Point1.y,n=this.Point2.x,a=this.Point2.y,h=t.Point1.x,p=t.Point1.y,w=t.Point2.x,r=t.Point2.y,f=(e-n)*(p-r)-(i-a)*(h-w);if(f===0)return[!1,new x(0,0)];const l=((e-h)*(p-r)-(i-p)*(h-w))/f,g=-((e-n)*(i-p)-(i-a)*(e-h))/f;return l>=0&&l<=1&&g>=0&&g<=1?[!0,new x(e+l*(n-e),i+l*(a-i))]:[!1,new x(0,0)]}}var A;(function(o){o[o.Top=0]="Top",o[o.Bottom=1]="Bottom",o[o.Left=2]="Left",o[o.Right=3]="Right"})(A||(A={}));class vt{constructor(t){s(this,"Entity");this.Entity=t}IsCollidingTerrain(t,e){const i=this.Entity.Bounds,n=S.Instance.MapManager.GameMap,a=S.Instance.MapManager.TerrainBlocks,h=S.Instance.MapManager.LineBlocks;if(n&&n.MapInfo){const p=n.MapInfo.tileheight,w=n.MapInfo.tilewidth;let r,f,l,g,I,V,R,D,b,d;switch(t){case 0:if(i.top+e<=0)return[!0,this.Entity.Position.y];let ft=Math.floor((i.top+e%p)/p),yt=Math.floor(i.top/p);l=Math.floor((i.left+.1)/w),g=Math.floor((i.right-.1)/w),d=new P(i.x+.1,i.y,i.width-.2,i.height);for(let c=yt;c>=ft;c--){const y=a.slice(n.MapInfo.width*c+l,n.MapInfo.width*c+g+1);for(let u=0;u<y.length;u++)if(y[u].IsValid&&y[u].BlockTypes&M.BottomBlocked&&y[u].Bounds.intersects(d))return[!0,y[u].Bounds.bottom]}I=new x(d.width/2+d.left,d.top+e),V=new x(d.width/2+d.left,d.bottom),b=new E(I,V);for(let c=0;c<h.length;c++){const[y,u]=h[c].Line.intersects(b);if(h[c].BlockTypes&M.BottomBlocked&&y)return[!0,u.y]}break;case 1:if(i.bottom+e>=n.Height)return[!0,this.Entity.Position.y];let gt=Math.floor(i.bottom/p),wt=Math.floor((i.bottom+e%p)/p);l=Math.floor((i.left+.1)/w),g=Math.floor((i.right-.1)/w),d=new P(i.x+.1,i.y,i.width-.2,i.height);for(let c=gt;c<=wt;c++){const y=a.slice(n.MapInfo.width*c+l,n.MapInfo.width*c+g+1);for(let u=0;u<y.length;u++)if(y[u].IsValid&&y[u].BlockTypes&M.TopBlocked&&y[u].Bounds.intersects(d))return[!0,y[u].Bounds.top-i.height]}I=new x(d.width/2+d.left,d.top),V=new x(d.width/2+d.left,d.bottom+e),b=new E(I,V);for(let c=0;c<h.length;c++){const[y,u]=h[c].Line.intersects(b);if(h[c].BlockTypes&M.TopBlocked&&y)return[!0,u.y-i.height]}break;case 2:if(i.left+e<=0)return[!0,this.Entity.Position.x];r=Math.round((i.top+.1)/p),f=Math.round((i.bottom-.1)/p);let mt=Math.floor(i.left/w),St=Math.floor((i.left+e%w)/w);d=new P(i.x,i.y+.1,i.width,i.height-.2);for(let c=r;c<f;c++){const y=a.slice(n.MapInfo.width*c+St,n.MapInfo.width*c+mt+1);for(let u=y.length-1;u>=0;u--){const _=y[u];if(_&&_.IsValid&&_.BlockTypes&M.RightBlocked&&_.Bounds.intersects(d))return[!0,_.Bounds.right+i.width/2]}}R=new x(d.left+e,d.height/2+d.top),D=new x(d.right,d.height/2+d.top),b=new E(R,D);for(let c=0;c<h.length;c++){const[y,u]=h[c].Line.intersects(b);if(h[c].BlockTypes&M.RightBlocked&&y)return[!0,u.x+i.width/2]}break;case 3:if(i.right+e>=n.Width)return[!0,this.Entity.Position.x];r=Math.round((i.top+.1)/p),f=Math.round((i.bottom-.1)/p);let Mt=Math.floor(i.right/w),It=Math.floor((i.right+e%w)/w);d=new P(i.x,i.y+.1,i.width,i.height-.2);for(let c=r;c<f;c++){const y=a.slice(n.MapInfo.width*c+Mt,n.MapInfo.width*c+It+1);for(let u=0;u<y.length;u++){const _=y[u];if(_&&_.IsValid&&_.BlockTypes&M.LeftBlocked&&_.Bounds.intersects(d))return[!0,_.Bounds.left-i.width/2]}}R=new x(d.left,d.height/2+d.top),D=new x(d.right+e,d.height/2+d.top),b=new E(R,D);for(let c=0;c<h.length;c++){const[y,u]=h[c].Line.intersects(b);if(h[c].BlockTypes&M.LeftBlocked&&y)return[!0,u.x-i.width/2]}break}}return[!1,0]}IsCollidingWithEntity(t){return t.Bounds.intersects(this.Entity.Bounds)}}class K{constructor(t,e){s(this,"x",0);s(this,"y",0);t&&(this.x=t),e&&(this.y=e)}static from(t){return new K(t.x,t.y)}Move(t,e){return this.MoveX(t),e&&this.MoveY(e),this}MoveX(t){return this.x+=t,this}MoveY(t){return this.y+=t,this}Multiply(t){return this.x*=t,this.y*=t,this}}class Et{constructor(t){s(this,"Animations",{});s(this,"PlayingAnimationName","");s(this,"PlayingAnimation");s(this,"CurrentTextureInd",-1);s(this,"AnimationDelay",100);s(this,"lastTick",0);t&&(this.Animations=t)}get CurrentTexture(){return this.PlayingAnimation&&this.PlayingAnimation.length>0&&this.CurrentTextureInd>=0?this.PlayingAnimation[this.CurrentTextureInd]:void 0}PlayAnimation(t,e=100){this.PlayingAnimationName!==t&&t in this.Animations&&(this.PlayingAnimationName=t,this.PlayingAnimation=this.Animations[t],this.lastTick=0,this.CurrentTextureInd=0,this.AnimationDelay=e)}StopAnimation(){this.PlayingAnimationName="",this.PlayingAnimation=void 0}Update(){this.PlayingAnimation&&(this.lastTick+=m.Instance.App.ticker.deltaMS,this.lastTick>=this.AnimationDelay&&(this.CurrentTextureInd=(this.CurrentTextureInd+1)%this.PlayingAnimation.length,this.lastTick-=this.AnimationDelay))}}class H{constructor(t,e){s(this,"_value");s(this,"_callbacks",[]);s(this,"_comparer");this._value=t,this._comparer=e}get Value(){return this._value}set Value(t){const e=this._value;this._value=t,(this._comparer?this._comparer(e,t):e!==t)&&this._callbacks.forEach(i=>i(t))}addListener(t){this._callbacks.push(t)}removeListener(t){this._callbacks=this._callbacks.filter(e=>e!==t)}}class N{constructor(t){s(this,"Entity");s(this,"_textures",[]);s(this,"AnimationsManager");s(this,"Rotation",0);s(this,"FlipX",new H(!1));s(this,"FlipY",new H(!1));s(this,"DefaultTexture");s(this,"CurrentSprite");this.Entity=t,this.CurrentSprite=new O,this.CurrentSprite.anchor.x=.5,this.CurrentSprite.position.set(this.Entity.Position.x,this.Entity.Position.y),this.FlipX.addListener(()=>{this.CurrentSprite.scale.x*=-1}),this.FlipY.addListener(()=>{this.CurrentSprite.scale.y*=-1}),m.Instance.EntitiesContainer.addChild(this.CurrentSprite)}get Textures(){return this._textures}get Size(){return{width:this.CurrentSprite.width,height:this.CurrentSprite.height}}static async Load(t,e){var n;const i=new N(t);try{const a=await U.Instance.Load(e),h=a.textures;i.AnimationsManager=new Et((n=a.spritesheet)==null?void 0:n.animations),h&&Object.values(h).forEach(p=>{p.baseTexture.scaleMode=G.NEAREST,i.DefaultTexture||(i.DefaultTexture=p),i.Textures.push(p)})}catch(a){throw console.error(`Failed when loading texture from ${e}`),a}return i}Update(){let t=!1;this.AnimationsManager&&(this.AnimationsManager.Update(),this.AnimationsManager.CurrentTexture&&(this.CurrentSprite.texture=this.AnimationsManager.CurrentTexture,t=!0)),!t&&this.DefaultTexture&&(this.CurrentSprite.texture=this.DefaultTexture),this.CurrentSprite.position.set(this.Entity.Position.x,this.Entity.Position.y)}Destroy(){m.Instance.EntitiesContainer.removeChild(this.CurrentSprite)}}class at{constructor(){s(this,"_position");s(this,"_view");this._position=new K}get Position(){return this._position}get View(){return this._view}InitEntityView(t){N.Load(this,t).then(e=>{this._view=e})}}class X extends at{constructor(){super(...arguments);s(this,"_collisionController");s(this,"_isOnGround",!1)}get CollisionController(){return this._collisionController||(this._collisionController=new vt(this)),this._collisionController}get IsOnGround(){return this._isOnGround}get Bounds(){var e,i,n,a;const t=(i=(e=this.View)==null?void 0:e.Size.width)!=null?i:0;return new P(this.Position.x-t/2,this.Position.y,t,(a=(n=this.View)==null?void 0:n.Size.height)!=null?a:0)}}class Vt extends X{constructor(){super();s(this,"_bounds",new P);s(this,"BlockTypes",M.None)}get Bounds(){return this._bounds}set Bounds(t){this._bounds=t}get IsValid(){return this.Bounds.width>0&&this.Bounds.height>0}Update(){}}class Rt{constructor(t){s(this,"_line");s(this,"BlockTypes",M.None);this._line=t}get Line(){return this._line}}class ht extends X{constructor(){super(...arguments);s(this,"_interacted",!1)}Interact(t){return!this._interacted&&this.CollisionController.IsCollidingWithEntity(t)?(this.OnInteract(t),this._interacted=!0,!0):!1}}class lt{constructor(t){s(this,"entity");s(this,"_easeOutSpeed",3);s(this,"_easeInSpeed",3);this.entity=t}get EaseInSpeed(){return this._easeInSpeed}set EaseInSpeed(t){t>=1&&(this._easeInSpeed=t)}get EaseOutSpeed(){return this._easeOutSpeed}set EaseOutSpeed(t){t>=1&&(this._easeOutSpeed=t)}MoveLeft(){this.entity.HorizontalSpeed>0&&(this.entity.HorizontalSpeed=0);const t=this.entity.HorizontalSpeed/this.EaseInSpeed;this.entity.HorizontalSpeed+=(t===0?-1:t)*m.Instance.TimerDelta}MoveRight(){this.entity.HorizontalSpeed<0&&(this.entity.HorizontalSpeed=0);const t=this.entity.HorizontalSpeed/this.EaseInSpeed;this.entity.HorizontalSpeed+=(t===0?1:t)*m.Instance.TimerDelta}MoveUp(){this.entity.VerticalSpeed<0&&(this.entity.VerticalSpeed=0);const t=this.entity.VerticalSpeed/this.EaseInSpeed;this.entity.VerticalSpeed+=(t===0?1:t)*m.Instance.TimerDelta}MoveDown(){this.entity.VerticalSpeed>0&&(this.entity.VerticalSpeed=0);const t=this.entity.VerticalSpeed/this.EaseInSpeed;this.entity.VerticalSpeed+=(t===0?-1:t)*m.Instance.TimerDelta}StopHorizontal(){if(this.entity.HorizontalSpeed<=.1&&this.entity.HorizontalSpeed>=-.1)this.entity.HorizontalSpeed=0;else if(this.entity.HorizontalSpeed>.1||this.entity.HorizontalSpeed<-.1){const t=this.entity.HorizontalSpeed/this.EaseOutSpeed;this.entity.HorizontalSpeed-=t*m.Instance.TimerDelta}}StopVertical(){if(this.entity.VerticalSpeed<=.1&&this.entity.VerticalSpeed>=-.1)this.entity.VerticalSpeed=0;else if(this.entity.VerticalSpeed>.1||this.entity.VerticalSpeed<-.1){const t=this.entity.VerticalSpeed/this.EaseOutSpeed;this.entity.VerticalSpeed-=t*m.Instance.TimerDelta}}}var k;(function(o){o[o.Left=0]="Left",o[o.Right=1]="Right"})(k||(k={}));class ct extends at{constructor(){super(...arguments);s(this,"_maxHorizontalSpeed",10);s(this,"_maxUpSpeed",10);s(this,"_maxDownSpeed",-10);s(this,"_moveController");s(this,"_horizontalSpeed",0);s(this,"_verticalSpeed",0);s(this,"_direction",1)}get MaxHorizontalSpeed(){return this._maxHorizontalSpeed}set MaxHorizontalSpeed(t){this._maxHorizontalSpeed=t}get MaxUpSpeed(){return this._maxUpSpeed}set MaxUpSpeed(t){this._maxUpSpeed=t}get MaxDownSpeed(){return this._maxDownSpeed}set MaxDownSpeed(t){this._maxDownSpeed=t}get MoveController(){return this._moveController||(this._moveController=new lt(this)),this._moveController}set MoveController(t){this._moveController=t}get HorizontalSpeed(){return this._horizontalSpeed}set HorizontalSpeed(t){t>this._maxHorizontalSpeed?this._horizontalSpeed=this._maxHorizontalSpeed:t<-this._maxHorizontalSpeed?this._horizontalSpeed=-this.MaxHorizontalSpeed:(this._horizontalSpeed=t,t>0?this._direction=1:t<0&&(this._direction=0))}get VerticalSpeed(){return this._verticalSpeed}set VerticalSpeed(t){t>this.MaxUpSpeed?this._verticalSpeed=this.MaxUpSpeed:t<this.MaxDownSpeed?this._verticalSpeed=this.MaxDownSpeed:this._verticalSpeed=t}get Direction(){return this._direction}set Direction(t){this._direction=t}}class Dt extends lt{constructor(t){super(t);s(this,"player");this.player=t}Jump(){return this.player.IsOnGround?(this.player.VerticalSpeed=this.player.MaxUpSpeed,!0):!1}StopVertical(){if(this.player.IsOnGround)this.player.VerticalSpeed=-2;else if(this.player.VerticalSpeed>=0&&this.player.VerticalSpeed<=1)this.player.VerticalSpeed=-2;else{let t=Math.abs(this.player.VerticalSpeed)/5*m.Instance.TimerDelta;this.player.VerticalSpeed-t>=this.player.MaxDownSpeed?this.player.VerticalSpeed-=t:this.player.VerticalSpeed=this.player.MaxDownSpeed}}}class Ot{constructor(){s(this,"_score",new H(0))}get Score(){return this._score}AddScore(t){this._score.Value+=t}}var dt;(function(o){o[o.Standing=0]="Standing",o[o.Running=1]="Running",o[o.Jumping=2]="Jumping"})(dt||(dt={}));class pt extends kt(ct,X){constructor(){super();s(this,"ScoreManager",new Ot);s(this,"State");this.State=0,this.MaxHorizontalSpeed=4,this.MaxUpSpeed=25,this.Position.x=100,this.MoveController=new Dt(this),this.InitEntityView("/assets/entities/player.json")}Update(){!S.Instance.MapManager.IsReady.Value||(this.View&&(this.View.FlipX.Value=this.Direction===k.Left,this.View.Update()),this.UpdatePosition(),this.UpdateState(),this.UpdateAnimation(),this.CheckInteractionsAndTrigger())}UpdatePosition(){const t=this.HorizontalSpeed*m.Instance.TimerDelta,[e,i]=this.CollisionController.IsCollidingTerrain(A.Left,t),[n,a]=this.CollisionController.IsCollidingTerrain(A.Right,t);this.HorizontalSpeed<0&&e?this.Position.x=i:this.HorizontalSpeed>0&&n?this.Position.x=a:this.Position.MoveX(t);const h=-this.VerticalSpeed*m.Instance.TimerDelta,[p,w]=this.CollisionController.IsCollidingTerrain(A.Top,h),[r,f]=this.CollisionController.IsCollidingTerrain(A.Bottom,h);this.VerticalSpeed>0&&p?(this.VerticalSpeed=-1,this._isOnGround=!1,this.Position.y=w):this.VerticalSpeed<0&&r?(this._isOnGround=!0,this.Position.y=f):(this.Position.MoveY(h),this._isOnGround=!1)}UpdateState(){this.IsOnGround?this.HorizontalSpeed===0?this.State=0:this.State=1:this.State=2}UpdateAnimation(){if(this.View&&this.View.AnimationsManager)switch(this.State){case 0:this.View.AnimationsManager.PlayAnimation("player-stand",300);break;case 1:this.View.AnimationsManager.PlayAnimation("player-walk",150);break;case 2:this.View.AnimationsManager.PlayAnimation("player-jump");break;default:this.View.AnimationsManager.StopAnimation();break}}CheckInteractionsAndTrigger(){S.Instance.MapManager.InteractableObjects.forEach(t=>{t instanceof ht&&t.Interact(this)})}}const tt=class extends ht{constructor(){super();s(this,"OnInteract");this.InitEntityView("/assets/entities/pie.json"),this.OnInteract=this.OnInteractCallback.bind(this),S.Instance.EntitiesList.push(this)}Update(){this.View&&this.View.Update()}OnInteractCallback(t){t instanceof pt&&(this.Destroy(),t.ScoreManager.AddScore(tt.VALUE))}Destroy(){var t;S.Instance.EntitiesList.remove(this),(t=this.View)==null||t.Destroy()}};let W=tt;s(W,"VALUE",10);class J{constructor(){s(this,"_mapInfo");s(this,"SpritesContainer",new L)}get MapInfo(){return this._mapInfo}get Height(){var t,e,i,n;return((e=(t=this.MapInfo)==null?void 0:t.height)!=null?e:0)*((n=(i=this.MapInfo)==null?void 0:i.tileheight)!=null?n:0)}get Width(){var t,e,i,n;return((e=(t=this.MapInfo)==null?void 0:t.width)!=null?e:0)*((n=(i=this.MapInfo)==null?void 0:i.tilewidth)!=null?n:0)}static async Load(t){const e=new J;try{const i=await(await fetch(t)).json();return e._mapInfo=i,e}catch(i){throw console.error(`Failed when loading map from ${t}`),i}}Init(){const t=[],e=[],i=[],n=this.MapInfo.layers.find(r=>r.name==="Terrain");if(n&&n.data&&n.height)for(let r=0;r<n.height;r++)n.data.splice(0,n.width).forEach((l,g)=>{if(t.push(new Vt),l>0){const I=new O(T.Instance.Textures[l-1]);I.x=g*I.texture.width,I.y=r*I.texture.height,this.SpritesContainer.addChild(I)}});const a=this.MapInfo.layers.find(r=>r.name==="Background");if(a&&a.data&&a.height)for(let r=0;r<a.height;r++)a.data.splice(0,a.width).forEach((l,g)=>{if(l>0){const I=new O(T.Instance.Textures[l-1]);I.x=g*I.texture.width,I.y=r*I.texture.height,this.SpritesContainer.addChild(I)}});const h=this.MapInfo.layers.find(r=>r.name==="BlocksCollisions");h&&h.objects&&h.objects.forEach(r=>{const f=Math.floor(r.y/this.MapInfo.tileheight*this.MapInfo.width+r.x/this.MapInfo.tilewidth);f<t.length&&(t[f].Bounds=new P(r.x,r.y,r.width,r.height),r.properties&&r.properties.forEach(l=>{l.name===C.TopBlocked&&l.value&&(t[f].BlockTypes|=M.TopBlocked),l.name===C.BottomBlocked&&l.value&&(t[f].BlockTypes|=M.BottomBlocked),l.name===C.LeftBlocked&&l.value&&(t[f].BlockTypes|=M.LeftBlocked),l.name===C.RightBlocked&&l.value&&(t[f].BlockTypes|=M.RightBlocked)}))});const p=this.MapInfo.layers.find(r=>r.name==="LineCollisions");p&&p.objects&&p.objects.forEach(r=>{if(r.polyline&&r.properties){const f=r.polyline.map(g=>new x(g.x+r.x,g.y+r.y)),l=new Rt(new E(f[0],f[1]));r.properties.forEach(g=>{g.name===C.TopBlocked&&g.value&&(l.BlockTypes|=M.TopBlocked),g.name===C.BottomBlocked&&g.value&&(l.BlockTypes|=M.BottomBlocked),g.name===C.LeftBlocked&&g.value&&(l.BlockTypes|=M.LeftBlocked),g.name===C.RightBlocked&&g.value&&(l.BlockTypes|=M.RightBlocked)}),e.push(l)}});const w=this.MapInfo.layers.find(r=>r.name==="InteractableObjects");return w&&w.objects&&w.objects.forEach(r=>{r.properties&&r.properties.forEach(f=>{if(f.name===C.IsPie&&f.value){const l=new W;l.Position.x=r.x,l.Position.y=r.y,i.push(l)}})}),[t,e,i]}}class zt{constructor(){s(this,"_gameMap");s(this,"_terrainBlocks",[]);s(this,"_lineBlocks",[]);s(this,"_interactableObjects",[]);s(this,"IsReady",new H(!1));this.Init()}get GameMap(){return this._gameMap}get TerrainBlocks(){return this._terrainBlocks}get LineBlocks(){return this._lineBlocks}get InteractableObjects(){return this._interactableObjects}get Width(){var t,e;return(e=(t=this.GameMap)==null?void 0:t.Width)!=null?e:0}get Height(){var t,e;return(e=(t=this.GameMap)==null?void 0:t.Height)!=null?e:0}async Init(){await T.Instance.Load("/assets/maps/cyber-street.json"),await T.Instance.Load("/assets/maps/residential.json"),this._gameMap=await J.Load("/assets/maps/map1.json"),[this._terrainBlocks,this._lineBlocks,this._interactableObjects]=this._gameMap.Init(),m.Instance.MapContainer.addChild(this._gameMap.SpritesContainer),this.IsReady.Value=!0}}const et=class{constructor(){s(this,"_player");s(this,"_mapManager");s(this,"EntitiesList",[]);this._player=new pt,this.EntitiesList.push(this._player),this._mapManager=new zt}static get Instance(){return this._instance||(this._instance=new et),this._instance}static DestroyInstance(){this._instance=void 0}get Player(){return this._player}get MapManager(){return this._mapManager}Update(){v.Instance.Handle(),this.EntitiesList.forEach(t=>{t.Update()})}};let S=et;s(S,"_instance");const it=class{constructor(){s(this,"Layers",[new L,new L,new L,new L]);const t=e=>{e&&(S.Instance.MapManager.IsReady.removeListener(t),this.Init())};S.Instance.MapManager.IsReady.addListener(t),m.Instance.BackgroundContainer.position.y-=64*3,m.Instance.BackgroundContainer.addChild(this.Layers[0],this.Layers[1],this.Layers[2],this.Layers[3])}async Init(){const t=[[await B.fromURL("/assets/backgrounds/layer1/1.png")],[await B.fromURL("/assets/backgrounds/layer2/1.png"),await B.fromURL("/assets/backgrounds/layer2/2.png")],[await B.fromURL("/assets/backgrounds/layer3/1.png"),await B.fromURL("/assets/backgrounds/layer3/2.png")],[await B.fromURL("/assets/backgrounds/layer4/1.png"),await B.fromURL("/assets/backgrounds/layer4/2.png")]];t.forEach(e=>{e.forEach(i=>{i.baseTexture.scaleMode=G.NEAREST})});for(let e=0;e<this.Layers.length;e++){const i=Math.round(S.Instance.MapManager.Width/t[e][0].width);for(let n=0;n<i;n++){const a=t[e][Math.random()*t[e].length|0],h=new O(a),p=a.width/a.height;h.height=m.Instance.App.screen.height,h.width=h.height*p,h.position.x=n*h.width,this.Layers[e].addChild(h)}}}Update(t){for(let e=0;e<this.Layers.length;e++)this.Layers[this.Layers.length-1-e].position.x=t*it.PARALLAX_BACKGROUND_SPEEDS[e]}};let Y=it;s(Y,"PARALLAX_BACKGROUND_SPEEDS",[.95,.9,.87,.86]);const st=class extends ct{constructor(){super();s(this,"Background",new Y);s(this,"Scale",2);s(this,"PlayerOffset",.45);s(this,"DirectionChangeOffset",.3);s(this,"CameraMoveDirection",S.Instance.Player.Direction);this.MaxHorizontalSpeed=8}static get Instance(){return this._instance||(this._instance=new st),this._instance}Update(t){const e=S.Instance.Player,i=e.Position.x*this.Scale,n=e.MaxHorizontalSpeed*this.Scale,a=m.Instance.App.screen.width,h=a*this.PlayerOffset,p=a-h,w=a*this.DirectionChangeOffset,r=a-w;if(this.CameraMoveDirection===k.Right)if(e.Direction===k.Left&&i<-this.Position.x+w)this.CameraMoveDirection=k.Left;else if(e.Direction===k.Right&&i>=-this.Position.x+h){const l=-(i-h);this.Position.x>=l-n&&this.Position.x<=l+n?this.Position.x=l:this.MoveController.MoveLeft()}else this.MoveController.StopHorizontal();else if(this.CameraMoveDirection===k.Left)if(e.Direction===k.Right&&i>-this.Position.x+r)this.CameraMoveDirection=k.Right;else if(e.Direction===k.Left&&i<=-this.Position.x+p){const l=-(i-p);this.Position.x>=l-n&&this.Position.x<=l+n?this.Position.x=l:this.MoveController.MoveRight()}else this.MoveController.StopHorizontal();this.Position.MoveX(this.HorizontalSpeed);const f=-(S.Instance.MapManager.Width*this.Scale)+a;this.Position.x>0?this.Position.x=0:this.Position.x<f&&(this.Position.x=f),this.Position.y=-(S.Instance.MapManager.Height*this.Scale-m.Instance.App.screen.height),this.Background.Update(this.Position.x),t.scale.set(this.Scale),t.position.set(this.Position.x,this.Position.y)}};let $=st;s($,"_instance");const nt=class{constructor(){s(this,"App");s(this,"_timerDelta",1);s(this,"MainContainer",new L);s(this,"BackgroundContainer",new L);s(this,"MapContainer",new L);s(this,"EntitiesContainer",new L);this.App=new Lt,this.App.renderer.view.style.position="absolute",this.App.renderer.view.style.display="block",this.App.resizeTo=window,this.MainContainer.addChild(this.MapContainer,this.EntitiesContainer),this.App.stage.addChild(this.BackgroundContainer,this.MainContainer),this.App.view.setAttribute("tabindex","1"),this.App.view.addEventListener("keydown",t=>v.Instance.OnKeyDown(t.key)),this.App.view.addEventListener("keyup",t=>v.Instance.OnKeyUp(t.key)),document.body.appendChild(this.App.view),this.App.view.focus()}static get Instance(){return this._instance||(this._instance=new nt),this._instance}get FPS(){return this.App.ticker.FPS}get TimerDelta(){return this._timerDelta}async Init(){this.App.ticker.add(t=>{this._timerDelta=t,this.Update()})}Update(){$.Instance.Update(this.MainContainer),S.Instance.Update()}};let m=nt;s(m,"_instance");const j=ot.exports.jsx,ut=ot.exports.jsxs;function Ut(){const[o,t]=z.exports.useState(0);return z.exports.useEffect(()=>{S.Instance.Player.ScoreManager.Score.addListener(e=>{t(e)})},[]),ut("div",{children:["Score: ",o]})}function Ht(){const[o,t]=z.exports.useState(0);return z.exports.useEffect(()=>{m.Instance.Init(),setInterval(()=>{t(Math.floor(m.Instance.FPS*10)/10)},1e3)},[]),j("div",{className:"App",children:ut("div",{style:{position:"fixed",top:10,left:10,color:"white",zIndex:2},children:["FPS: ",o,j(Ut,{})]})})}bt.render(j(Pt.StrictMode,{children:j(Ht,{})}),document.getElementById("root"));
